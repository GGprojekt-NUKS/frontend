{"ast":null,"code":"export default {\n  data() {\n    return {\n      items: [],\n      selectedTopicId: 0,\n      newText: '',\n      textList: []\n    };\n  },\n  created() {\n    // Load topics and texts from server on component creation\n    this.loadTopics();\n    this.loadTexts();\n  },\n  methods: {\n    async loadTopics() {\n      // Send GET request to /topic_list to load topics from server\n      const response = await fetch('http://localhost:8000/topic_list');\n      const data = await response.json();\n      this.items = data.map((topic, index) => {\n        return {\n          id: index,\n          topic: topic\n        };\n      });\n    },\n    async loadTexts() {\n      // Send GET request to /text_list with selected topic ID to load texts from server\n      const response = await fetch(`http://localhost:8000/text_list?topic_id=${this.selectedTopicId}`);\n      const data = await response.json();\n      this.textList = data;\n    },\n    async saveText() {\n      // Send POST request to /add to save new text to server\n      const response = await fetch('http://localhost:8000/add', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          text: this.newText,\n          topic_id: this.selectedTopicId + 1\n        })\n      });\n      if (response.ok) {\n        this.newText = '';\n        this.loadTexts();\n      } else {\n        console.error('Failed to save text:', response.statusText);\n      }\n    }\n  },\n  computed: {\n    mergedItems() {\n      // Filter the textList to show only texts for the selected topic\n      return this.textList.filter(text => text.topic_id === this.selectedTopicId);\n    }\n  }\n};","map":{"version":3,"names":["data","items","selectedTopicId","newText","textList","created","loadTopics","loadTexts","methods","response","fetch","json","map","topic","index","id","saveText","method","headers","body","JSON","stringify","text","topic_id","ok","console","error","statusText","computed","mergedItems","filter"],"sources":["/home/nuksvaje/frontend/src/App.vue"],"sourcesContent":["<template>\n  <div>\n    <h1>FORUM</h1>\n    <div>\n      <h2>Pick a topic:</h2>\n      <select id=\"textDropdown\" v-model=\"selectedTopicId\" @change=\"loadTexts\">\n        <option v-for=\"item in items\" :value=\"item.id\" :key=\"item.id\">{{ item.topic }}</option>\n      </select>\n      <br>\n    </div>\n    <div>\n      <h2>Add new text:</h2>\n      <input type=\"text\" id=\"newText\" v-model=\"newText\">\n      <button @click=\"saveText\">Save</button>\n    </div>\n    <ul>\n      <li v-for=\"item in mergedItems\" :key=\"item.id\">\n        {{ item.text }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    return {\n      items: [],\n      selectedTopicId: 0,\n      newText: '',\n      textList: [],\n    };\n  },\n  created() {\n    // Load topics and texts from server on component creation\n    this.loadTopics();\n    this.loadTexts();\n  },\n  methods: {\n    async loadTopics() {\n      // Send GET request to /topic_list to load topics from server\n      const response = await fetch('http://localhost:8000/topic_list');\n      const data = await response.json();\n      this.items = data.map((topic, index) => {\n        return { id: index, topic: topic };\n      });\n    },\n    async loadTexts() {\n      // Send GET request to /text_list with selected topic ID to load texts from server\n      const response = await fetch(`http://localhost:8000/text_list?topic_id=${this.selectedTopicId}`);\n      const data = await response.json();\n      this.textList = data;\n    },\n    async saveText() {\n      // Send POST request to /add to save new text to server\n      const response = await fetch('http://localhost:8000/add', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({ text: this.newText, topic_id: this.selectedTopicId + 1 }),\n      });\n      if (response.ok) {\n        this.newText = '';\n        this.loadTexts();\n      } else {\n        console.error('Failed to save text:', response.statusText);\n      }\n    },\n  },\n  computed: {\n    mergedItems() {\n      // Filter the textList to show only texts for the selected topic\n      return this.textList.filter(text => text.topic_id === this.selectedTopicId);\n    },\n  },\n};\n</script>\n"],"mappings":"AAwBA,eAAe;EACbA,IAAIA,CAAA,EAAG;IACL,OAAO;MACLC,KAAK,EAAE,EAAE;MACTC,eAAe,EAAE,CAAC;MAClBC,OAAO,EAAE,EAAE;MACXC,QAAQ,EAAE;IACZ,CAAC;EACH,CAAC;EACDC,OAAOA,CAAA,EAAG;IACR;IACA,IAAI,CAACC,UAAU,EAAE;IACjB,IAAI,CAACC,SAAS,EAAE;EAClB,CAAC;EACDC,OAAO,EAAE;IACP,MAAMF,UAAUA,CAAA,EAAG;MACjB;MACA,MAAMG,QAAO,GAAI,MAAMC,KAAK,CAAC,kCAAkC,CAAC;MAChE,MAAMV,IAAG,GAAI,MAAMS,QAAQ,CAACE,IAAI,EAAE;MAClC,IAAI,CAACV,KAAI,GAAID,IAAI,CAACY,GAAG,CAAC,CAACC,KAAK,EAAEC,KAAK,KAAK;QACtC,OAAO;UAAEC,EAAE,EAAED,KAAK;UAAED,KAAK,EAAEA;QAAM,CAAC;MACpC,CAAC,CAAC;IACJ,CAAC;IACD,MAAMN,SAASA,CAAA,EAAG;MAChB;MACA,MAAME,QAAO,GAAI,MAAMC,KAAK,CAAE,4CAA2C,IAAI,CAACR,eAAgB,EAAC,CAAC;MAChG,MAAMF,IAAG,GAAI,MAAMS,QAAQ,CAACE,IAAI,EAAE;MAClC,IAAI,CAACP,QAAO,GAAIJ,IAAI;IACtB,CAAC;IACD,MAAMgB,QAAQA,CAAA,EAAG;MACf;MACA,MAAMP,QAAO,GAAI,MAAMC,KAAK,CAAC,2BAA2B,EAAE;QACxDO,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,cAAc,EAAE;QAClB,CAAC;QACDC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UAAEC,IAAI,EAAE,IAAI,CAACnB,OAAO;UAAEoB,QAAQ,EAAE,IAAI,CAACrB,eAAc,GAAI;QAAE,CAAC;MACjF,CAAC,CAAC;MACF,IAAIO,QAAQ,CAACe,EAAE,EAAE;QACf,IAAI,CAACrB,OAAM,GAAI,EAAE;QACjB,IAAI,CAACI,SAAS,EAAE;MAClB,OAAO;QACLkB,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAEjB,QAAQ,CAACkB,UAAU,CAAC;MAC5D;IACF;EACF,CAAC;EACDC,QAAQ,EAAE;IACRC,WAAWA,CAAA,EAAG;MACZ;MACA,OAAO,IAAI,CAACzB,QAAQ,CAAC0B,MAAM,CAACR,IAAG,IAAKA,IAAI,CAACC,QAAO,KAAM,IAAI,CAACrB,eAAe,CAAC;IAC7E;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}